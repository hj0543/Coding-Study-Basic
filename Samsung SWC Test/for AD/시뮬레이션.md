
# 📝 시뮬레이션 (Simulation) & 구현 (Implementation)

**날짜**: 2026. 02. 06 (금)
**주제**: 시뮬레이션 (Simulation) & 구현 (Implementation)
문제에서 제시하는 규칙과 상황을 **코드상에 그대로 재현**해내는 능력이다.

## 1. 시뮬레이션이란?

* **특징**: 복잡한 알고리즘(DFS/BFS 등)보다는 **주어진 요구사항을 정확하게 코드로 옮기는지**를 평가한다.
* **난이도**: 로직 자체는 어렵지 않으나, **조건이 많고 배열 인덱스 처리가 까다로워** 실수하기 딱 좋다.
* **A형 특징**: 주로 2차원 배열에서 **이동, 회전, 충돌, 중력, 폭발** 등의 규칙이 순차적으로 발생한다.

---

## 2. 필수 테크닉 ①: 배열 회전 (Rotation) ★★★

시뮬레이션 문제의 70% 이상이 배열 회전을 요구한다. 시험장에서 인덱스를 계산하고 있으면 늦다. **공식처럼 외워두는 것이 좋다.**

### 90도 시계 방향 회전 (Clockwise)

* 공식: **`(r, c)`  `(c, N - 1 - r)**`
* 1행이 1열로, 2행이 2열로... 이동하는 규칙이다.

```python
def rotate_90(arr):
    N = len(arr)
    # N x N 빈 배열 생성
    new_arr = [[0] * N for _ in range(N)]
    
    for r in range(N):
        for c in range(N):
            # [공식] (행, 열) -> (열, N-1-행)
            new_arr[c][N - 1 - r] = arr[r][c]
            
    return new_arr

# 팁: 180도 회전은 90도 회전을 두 번 호출하면 된다.
# 270도 회전은 90도 회전을 세 번 호출하거나, 반시계 공식을 쓴다.

```

### 90도 반시계 방향 회전 (Counter-Clockwise)

* 공식: **`(r, c)`  `(N - 1 - c, r)**`

---

## 3. 필수 테크닉 ②: 중력 (Gravity)

테트리스나 애니팡처럼, **빈 공간이 생겼을 때 위에 있는 요소들이 아래로 떨어지는** 구현이다.

### 구현 로직

1. **아래에서부터 위로(`N-1`  `0`)** 훑는다. (중요!)
2. 현재 칸이 비어있다면(`0`), 그 위의 칸들을 탐색해서 가장 먼저 만나는 물체를 끌어내린다.
3. 혹은, **1차원 배열로 생각해서 0을 제외한 값만 추출한 뒤 다시 채워 넣는 방식**이 더 쉽다.

```python
def apply_gravity(arr):
    N = len(arr) # 행
    M = len(arr[0]) # 열
    
    # 열(Col) 단위로 처리해야 함
    for j in range(M):
        temp = []
        # 1. 해당 열에서 0이 아닌 값만 추출 (순서 유지)
        for i in range(N):
            if arr[i][j] != 0:
                temp.append(arr[i][j])
        
        # 2. 아래서부터 채우기 위해, 
        # (전체 행 개수 - 실제 값 개수)만큼 0을 채우고 나머지를 넣음
        for i in range(N - len(temp)):
            arr[i][j] = 0 # 위쪽은 공기로 채움
            
        for i in range(len(temp)):
            # 아래쪽 채움 (temp는 위에서부터 추출했으므로 인덱스 조절 필요)
            arr[N - len(temp) + i][j] = temp[i]
            
    return arr

```

---

## 4. 필수 테크닉 ③: 달팽이 배열 (Snail / Spiral)

배열의 중앙에서 시작해 나선형으로 돌거나, (0,0)에서 안쪽으로 파고드는 패턴이다.

* **토네이도** 문제 유형의 기초가 된다.

### 구현 로직

* **방향 순서**: 좌  하  우  상 (또는 문제 조건에 따라 다름)
* **이동 거리**: `1, 1, 2, 2, 3, 3, 4, 4 ...` 처럼 **두 번 방향을 바꿀 때마다 이동 거리가 1씩 늘어나는 규칙**이 있다.

```python
def snail(N):
    arr = [[0] * N for _ in range(N)]
    r, c = N // 2, N // 2 # 정중앙 시작
    arr[r][c] = 1 # 시작점
    
    # 좌, 하, 우, 상
    dr = [0, 1, 0, -1]
    dc = [-1, 0, 1, 0]
    
    num = 2
    length = 1 # 이동 길이
    d_idx = 0 # 방향 인덱스
    
    while num <= N * N:
        # 같은 길이로 두 번 이동 (예: 좌로 1칸, 하로 1칸 / 우로 2칸, 상으로 2칸)
        for _ in range(2):
            for _ in range(length):
                r += dr[d_idx]
                c += dc[d_idx]
                
                if num > N * N: break # 종료 조건
                
                arr[r][c] = num
                num += 1
            
            # 방향 변경 (0->1->2->3->0...)
            d_idx = (d_idx + 1) % 4
            
        length += 1 # 두 번 방향 바꾸면 이동 거리 증가
        
    return arr

```

---

## 5. 필수 테크닉 ④: 경계 처리와 반사

벽(배열 끝)에 부딪히면 방향을 반대로 바꾸는 경우다.

* 공식: **`d = (d + 2) % 4`** (상(0), 우(1), 하(2), 좌(3) 순서일 때, 0  2, 1  3)
* 또는 간단하게 조건문으로 처리한다.

```python
# 이동하려는 곳(ni, nj)이 범위를 벗어났다면?
if not (0 <= ni < N and 0 <= nj < N):
    d = (d + 2) % 4 # 방향 반전 (상<->하, 좌<->우)
    # 반대 방향으로 다시 좌표 계산
    ni = i + dr[d]
    nj = j + dc[d]

```

---

## 6. 시뮬레이션 문제 해결 팁 (A형 대비)

1. **문제를 쪼개라 (모듈화)**:
* "이동 함수", "회전 함수", "폭발 함수" 처럼 기능별로 함수를 나눠서 짜야 디버깅이 가능하다. 통짜로 짜면 멘탈 나간다.


2. **딥카피(Deepcopy) 주의**:
* 배열 상태를 보존해야 하거나, 동시 이동을 구현할 때(모든 물고기가 동시에 이동 등)는 `new_arr`를 만들거나 `deepcopy`를 써야 기존 데이터 꼬임을 방지할 수 있다.


3. **지문 정독**:
* "동시에 이동한다" vs "순차적으로 이동한다"
* "자신을 포함한다" vs "포함하지 않는다"
* 이 조건 하나 차이로 정답이 갈린다.



---

✅ **다음 단계**
시뮬레이션은 이론보다 **직접 손으로 구현**해보는 것이 중요하다.
