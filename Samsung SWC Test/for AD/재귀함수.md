
# 📝 TIL: 재귀함수 (Recursion) - 나를 다시 부르는 함수

**날짜**: 2026. 02. 06 (금)
**주제**: 알고리즘 기초 / 재귀(Recursion)

## 1. 재귀함수란? (Concept)

* **정의**: 함수 내부에서 **자기 자신을 다시 호출**하는 함수.
* **핵심 아이디어**: 거대한 문제를 **동일한 구조의 더 작은 문제**로 쪼개서 해결하는 방식이다.
* **비유**:
* 마트료시카 인형 (열어도 열어도 계속 똑같은 인형이 나옴)
* 양쪽 거울 사이에 서 있을 때 생기는 무한 반사



---

## 2. 재귀의 필수 구성 요소 (The 2 Rules)

재귀함수를 짤 때 이 두 가지가 없으면 **무한 루프(Infinite Loop)**에 빠지거나 에러가 난다.

### ① 종료 조건 (Base Case)

* 재귀 호출을 **멈추는 조건**이다.
* 문제가 더 이상 쪼개질 수 없는 가장 작은 단위(Atomic level)에 도달했을 때 값을 반환한다.
* **역할**: 브레이크(Break). 이게 없으면 영원히 멈추지 않는다.

### ② 재귀 호출 (Recursive Case)

* 문제를 더 작게 만들어서 **자기 자신을 호출**하는 부분이다.
* **역할**: 엑셀(Accelerator). 종료 조건(Base Case)을 향해 달려가는 과정이다.

```python
def hello(count):
    # 1. 종료 조건 (Base Case)
    if count == 0:
        return
    
    # 2. 로직 수행
    print("Hello World!", count)
    
    # 3. 재귀 호출 (Recursive Case) -> count를 줄여서 호출
    hello(count - 1)

```

---

## 3. 동작 원리: 스택 (Call Stack)

재귀함수는 자료구조 **스택(Stack)**과 떼려야 뗄 수 없는 관계다.

1. 함수가 호출될 때마다 메모리의 **스택 영역**에 새로운 프레임(함수 정보)이 쌓인다 (**Push**).
2. 종료 조건(Base Case)을 만나면 가장 위에 있는 프레임부터 결과값을 반환하며 사라진다 (**Pop**).
3. **LIFO (Last-In First-Out)** 구조: 가장 나중에 호출된 함수가 가장 먼저 끝난다.

> **💡 깨달음**: 재귀함수는 단순히 "반복"하는 게 아니라, **깊이 들어갔다가(Winding) 다시 거슬러 올라오는(Unwinding)** 과정이 있구나!

---

## 4. 대표 예제: 팩토리얼 (Factorial)

 이라는 수학적 정의 자체가 재귀적이다.

### 코드 흐름 (`factorial(3)`을 호출했을 때)

1. `factorial(3)` 호출  `3 * factorial(2)` 대기
2. `factorial(2)` 호출  `2 * factorial(1)` 대기
3. `factorial(1)` 호출  `1` 반환 (**Base Case 도달!**)
4. `factorial(2)` 재개  `2 * 1 = 2` 반환
5. `factorial(3)` 재개  `3 * 2 = 6` 반환 **(최종 결과)**

```python
def factorial(n):
    if n <= 1: # Base Case
        return 1
    return n * factorial(n - 1) # Recursive Case

```

---

## 5. 주의할 점 (Troubleshooting)

### ① 스택 오버플로우 (Stack Overflow)

종료 조건이 없거나 너무 깊게 들어가면 스택 메모리가 꽉 차서 프로그램이 터진다.

* 파이썬의 기본 재귀 깊이 제한은 보통 **1,000번**이다.
* **해결책**:
```python
import sys
sys.setrecursionlimit(10**6) # 제한 늘리기 (알고리즘 풀 때 필수)

```



### ② 성능 문제

단순 반복문(`for`, `while`)보다 함수 호출 오버헤드(메모리 생성/삭제 비용) 때문에 **속도가 느리고 메모리를 많이 쓴다**.

* 하지만 **DFS(깊이 우선 탐색), 트리 순회, 하노이의 탑** 같은 문제는 재귀로 짜는 것이 코드가 훨씬 직관적이고 깔끔하다.

---

## 6. 오늘의 결론 (Takeaway)

> "재귀함수는 **'나는 이 문제의 아주 작은 부분만 해결할게, 나머지는 똑같은 나(함수)한테 맡길게'**라고 위임하는 방식이다."

* **언제 쓸까?**: 문제가 반복적인 구조(트리, 그래프 등)를 가질 때.
* **어떻게 짤까?**: 코드를 쓰기 전에 **"언제 멈출 것인가(Base Case)"**부터 고민하자.