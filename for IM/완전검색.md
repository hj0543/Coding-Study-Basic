
# 📂 IM 핵심 정복: 완전 검색 (Brute Force)

> **"컴퓨터는 생각보다 빠르다. 고민할 시간에 다 돌려라."**

IM 난이도에서는 데이터의 크기()가 작다. (보통 100 이하)
복잡한 공식을 찾으려 하지 말고, **가능한 모든 경우의 수**를 코드로 옮기는 것이 정답이다.

## 1. 완전 검색이란?

* **정의**: 문제 해결을 위해 **발생할 수 있는 모든 경우**를 하나도 빠짐없이 검사하는 기법.
* **IM 공략법**:
* 이 100 정도라면 3중 `for`문()을 돌려도 0.1초도 안 걸린다.
* "이거 시간 초과 안 나나?" 걱정하기 전에 입력 크기(Constraints)를 먼저 보자.



---

## 2. 대표 유형 ①: 조합 (Combination) - 반복문 활용

순서 상관없이 개 중 개를 뽑는 경우.
재귀함수(Backtracking)를 몰라도, IM에서는 **다중 반복문**으로 충분히 해결 가능하다.

### 💡 예제: 일곱 난쟁이 [BOJ 2309]

**문제**: 9명의 난쟁이 중 키의 합이 100이 되는 7명을 찾아라.
**역발상**: 7명을 찾는 것(7중 for문)보다, **빠져야 할 가짜 2명을 찾는 것(2중 for문)**이 훨씬 쉽다.

```python
# 난쟁이 9명의 키 리스트
dwarfs = [20, 7, 23, 19, 10, 15, 25, 8, 13]
total_sum = sum(dwarfs)
N = 9

found = False
# 2명을 뽑는 모든 경우의 수 (i는 첫 번째, j는 두 번째)
for i in range(N):
    for j in range(i + 1, N): # j는 i 다음부터 시작 (중복 방지)
        
        # 만약 전체에서 두 명을 뺐을 때 100이 된다면?
        if total_sum - (dwarfs[i] + dwarfs[j]) == 100:
            fake1, fake2 = dwarfs[i], dwarfs[j]
            
            # 리스트에서 제거 (값으로 제거)
            dwarfs.remove(fake1)
            dwarfs.remove(fake2)
            dwarfs.sort() # 오름차순 정렬
            
            print(*dwarfs, sep='\n')
            found = True
            break
            
    if found: break # 답을 찾았으면 전체 반복 종료

```

---

## 3. 대표 유형 ②: 패턴 찾기 (2D Matrix Search)

큰 격자 안에서 작은 격자(패턴)가 존재하는지, 혹은 가장 큰 합을 찾는 문제.

### 💡 예제: N x M 격자 안에서 K x K 최대 합 구하기

**핵심**: 시작점 `(r, c)`를 기준으로 `K x K`를 매번 순회한다. (4중 for문 구조가 나오지만 쫄지 말자.)

```python
N, M = 10, 10 # 전체 크기
K = 3         # 찾고 싶은 영역 크기
grid = [[...]] # 데이터 생략

max_sum = -1

# 1. 가능한 모든 시작점 (r, c) 순회
# K x K 가 범위를 벗어나지 않도록 (N - K + 1) 까지만 반복
for r in range(N - K + 1):
    for c in range(M - K + 1):
        
        # 2. 해당 시작점부터 K x K 영역 합 구하기
        current_sum = 0
        for i in range(K):
            for j in range(K):
                current_sum += grid[r + i][c + j]
        
        # 최댓값 갱신
        if current_sum > max_sum:
            max_sum = current_sum

print(max_sum)

```

---

## 💡 완전 검색 문제 풀이 팁

1. **입력 제한 확인**:  정도면 재귀나 4~5중 반복문도 가능하다.  이면 3중 반복문까지 안전하다.
2. **`itertools` 사용?**: 파이썬의 `combinations`, `permutations`를 쓰면 코드가 짧아지지만, 삼성 SW 테스트 일부 환경에서는 `import` 제한이 없더라도 **직접 구현하는 것**을 연습하는 게 로직 이해에 좋다. IM은 반복문 구현력을 보기 때문이다.
3. **Break 활용**: 답을 찾았으면 `break`로 반복문을 즉시 탈출하여 불필요한 연산을 줄이자. (플래그 변수 활용)