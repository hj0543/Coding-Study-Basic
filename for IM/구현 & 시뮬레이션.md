
# 📂 IM 핵심 정복: 단순 구현 & 시뮬레이션

알고리즘적 사고보다는 **"문해력"**과 **"꼼꼼함"**이 승부처다.
문제에 적힌 절차를 하나도 빠짐없이 코드로 옮기는 연습이 필요하다.

## 1. 스위치 켜고 끄기 (Toggle & Range)

IM 등급의 바이블과 같은 유형. **[BOJ 1244 스위치 켜고 끄기]**가 대표적이다.

### 🔹 핵심 역량

1. **Toggle**: `0`을 `1`로, `1`을 `0`으로 바꾸기.
* `val = 1 - val` (가장 깔끔함)
* `val = (val + 1) % 2`
* `val = not val` (True/False일 때)


2. **배수 처리**: `range()` 함수의 `step` 파라미터 활용.
3. **대칭 검사 (Palindrome)**: 기준점을 중심으로 좌우로 퍼져나가며 비교하기.

### 📝 코드 패턴

```python
# 스위치 상태 (1번부터 쓰기 위해 앞에 [-1] 더미 추가)
switches = [-1] + [0, 1, 0, 1, 0, 0, 0, 1] 
N = len(switches) - 1

def change_switch(idx):
    # 0 -> 1, 1 -> 0 토글 공식
    switches[idx] = 1 - switches[idx]

# Case 1: 남학생 (num의 배수 번호 스위치 조작)
def boy_action(num):
    for i in range(num, N + 1, num): # num부터 끝까지, num칸씩 점프
        change_switch(i)

# Case 2: 여학생 (num을 중심으로 좌우가 대칭인 구간 조작)
def girl_action(num):
    change_switch(num) # 일단 자기 자신은 무조건 바꿈
    
    # 좌우로 펼쳐나가기
    left, right = num - 1, num + 1
    while left >= 1 and right <= N:
        if switches[left] == switches[right]:
            change_switch(left)
            change_switch(right)
            left -= 1
            right += 1
        else:
            break # 대칭 아니면 즉시 중단

```

---

## 2. 줄 세우기 (List Insertion)

리스트의 중간에 요소를 넣거나 빼는 유형. **[BOJ 2605 줄 세우기]**가 대표적이다.

### 🔹 핵심 역량

1. **Insert**: `list.insert(index, value)` 함수 사용.
* `index` 위치에 값을 넣으면, 기존 값들은 자동으로 **오른쪽으로 한 칸씩 밀린다.**


2. **규칙 찾기**: 문제에서 말하는 "앞에서 몇 번째"가 인덱스로는 얼마인지 매핑하기.
* 예: "3번 학생이 1장을 뽑으면?"  "자기 위치에서 1칸 앞으로 감"



### 📝 코드 패턴

```python
# 학생 수: 5
# 학생들이 뽑은 번호표: 0 1 1 3 2
numbers = [0, 1, 1, 3, 2]
line = [] # 줄을 설 빈 리스트

for i in range(5):
    student_id = i + 1  # 학생 번호 (1번부터)
    move_cnt = numbers[i] # 앞으로 갈 칸 수
    
    # [핵심 로직]
    # 맨 뒤에 서려고 했는데(len(line)), move_cnt만큼 앞으로 간다.
    # insert 위치 = (현재 줄의 길이) - (앞으로 갈 칸 수)
    insert_idx = len(line) - move_cnt
    
    line.insert(insert_idx, student_id)

print(*line) 
# 결과: 4 2 5 3 1

```

> **⚠️ 주의**: `insert`는 시간 복잡도가 `O(N)`이다. N이 크면 느리지만, IM 문제(N <= 100)에서는 마음껏 써도 된다.

---

## 3. 색종이 붙이기 (2D Array Filling)

도화지에 색종이를 붙여 면적을 구하는 유형. **[BOJ 2563 색종이]**가 대표적이다.

### 🔹 핵심 역량

1. **겹침 처리**: 수학적으로 겹치는 면적을 계산하려고 하면 어렵다.
* **2차원 배열(도화지)을 만들고, 해당 영역을 `1`로 덮어쓰기(Marking) 한다.**
* 이미 `1`인 곳에 또 `1`을 써도 상관없다.


2. **면적 구하기**: 모든 작업이 끝난 후 배열 전체의 `1`의 개수를 `sum()` 한다.

### 📝 코드 패턴

```python
# 100 x 100 도화지 (흰색: 0)
paper = [[0] * 100 for _ in range(100)]

# 색종이 정보 (왼쪽 벽 거리 x, 아래쪽 벽 거리 y)
# 크기는 10 x 10 으로 고정
papers = [(3, 7), (15, 7), (5, 2)]

for x, y in papers:
    # 2중 for문으로 영역 채우기
    # x부터 x+10, y부터 y+10 까지
    for i in range(x, x + 10):
        for j in range(y, y + 10):
            paper[i][j] = 1 # 검은색으로 칠하기 (덮어쓰기)

# 전체 검은 영역 넓이 구하기
total_area = 0
for row in paper:
    total_area += sum(row) # 각 행의 1 개수 합산

print(total_area)

```

---

## 💡 구현/시뮬레이션 문제 풀이 팁

1. **손으로 먼저 해보기**: 예제 입력을 보고 손으로 직접 과정을 그려본 뒤 코드를 짠다.
2. **Index 확인**: "3번째"가 `arr[3]`인지 `arr[2]`인지 항상 의심하라.
3. **조건 누락 체크**: 문제 지문의 단서 조항(단, ~인 경우는 제외한다 등)을 꼭 주석으로 적어두자.