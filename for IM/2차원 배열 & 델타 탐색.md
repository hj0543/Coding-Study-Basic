
# 📂 IM 핵심 정복: 2차원 배열 & 델타 탐색

IM 시험의 60% 이상은 **격자(Grid) 위에서 벌어지는 시뮬레이션**이다.
이것만 자유자재로 다뤄도 합격선에 들어간다.

## 1. 델타 탐색 (Delta Search) 개념

현재 위치 `(r, c)`를 기준으로 상하좌우(또는 대각선)로 이동하거나 주변을 탐색하는 기법.
일일이 `if`문을 4번 쓰는 것이 아니라, **방향 배열(`dr`, `dc`)**을 만들어 반복문으로 처리한다.

### 🔹 기본 공식 (암기 필수)

```python
# 상, 하, 좌, 우 (문제에 따라 순서 바뀔 수 있음)
dr = [-1, 1, 0, 0] # 행(Row) 이동량
dc = [0, 0, -1, 1] # 열(Col) 이동량

# N x N 배열 순회
for r in range(N):
    for c in range(N):
        # 4방향 탐색
        for k in range(4):
            nr = r + dr[k]
            nc = c + dc[k]
            
            # [필수] 범위 체크 (IndexError 방지)
            if 0 <= nr < N and 0 <= nc < N:
                # 여기에 로직 작성 (예: arr[nr][nc] 값 확인)
                print(arr[nr][nc])

```

---

## 2. 확장 스킬: 한 방향으로 쭉 가기 (오목, 빙고)

단순히 바로 옆칸만 보는 게 아니라, **특정 방향으로 K칸만큼** 계속 뻗어나가야 할 때가 있다.
(예: 오목, 단어 찾기, 포탑 발사)

### 🔹 구현 패턴

```python
# 예: 현재 위치(r, c)에서 '우하향 대각선'으로 5칸이 같은 색인지 확인
# 우하향 델타: 행+1, 열+1
dr, dc = 1, 1 

cnt = 0
for k in range(5): # 0칸 ~ 4칸 떨어진 곳까지 확인
    nr = r + (dr * k) # k를 곱해서 거리를 늘림
    nc = c + (dc * k)
    
    if 0 <= nr < N and 0 <= nc < N and arr[nr][nc] == 1:
        cnt += 1
    else:
        break # 중간에 끊기면 중단

if cnt == 5:
    print("오목 완성!")

```

---

## 3. 배열 회전 (Rotate)

IM/A형 불문하고 자주 나오는 패턴. 90도 시계방향 회전 공식은 외워두는 게 편하다.

### 🔹 90도 시계방향 회전 공식

`새로운 열(nc)` = `기존 행(r)`을 뒤집은 것(`N-1-r`)
`새로운 행(nr)` = `기존 열(c)`

```python
def rotate_90(arr):
    N = len(arr)
    ret = [[0] * N for _ in range(N)]
    
    for r in range(N):
        for c in range(N):
            # [공식] (행, 열) -> (열, N-1-행)
            ret[c][N - 1 - r] = arr[r][c]
            
    return ret

```

---

## 📝 실전 예제 풀이

### 💡 예제 1: 지뢰 찾기 (이웃한 요소 개수 세기)

**문제**: `N x N` 격자에 `1`(지뢰)과 `0`(빈칸)이 있다. 각 칸의 주변 8방향(상하좌우+대각선)에 지뢰가 몇 개 있는지 세어서 출력하라.

```python
def count_mines(grid):
    N = len(grid)
    result = [[0] * N for _ in range(N)]
    
    # 8방향 델타 (상, 하, 좌, 우, 좌상, 우상, 좌하, 우하)
    dr = [-1, 1, 0, 0, -1, -1, 1, 1]
    dc = [0, 0, -1, 1, -1, 1, -1, 1]
    
    for r in range(N):
        for c in range(N):
            # 현재 칸이 지뢰라면 계산 안 함 (문제 조건에 따라 다름)
            if grid[r][c] == 1:
                result[r][c] = '*'
                continue
            
            mine_cnt = 0
            # 8방향 탐색
            for k in range(8):
                nr, nc = r + dr[k], c + dc[k]
                
                # 범위 체크 & 지뢰 확인
                if 0 <= nr < N and 0 <= nc < N:
                    if grid[nr][nc] == 1:
                        mine_cnt += 1
            
            result[r][c] = mine_cnt
            
    return result

# 테스트
data = [
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1]
]
# 출력해보면 주변 지뢰 개수가 채워져 있음

```

---

### 💡 예제 2: 빙고 (선 긋기) - [BOJ 2578번 스타일]

**문제**: 5x5 빙고판에서 가로, 세로, 대각선 중 3줄이 완성되면 "Bingo!"를 외친다.

**핵심 로직**:

1. 사회자가 부른 숫자를 찾아 지운다 (0으로 변경).
2. 가로 5줄, 세로 5줄, 대각선 2줄을 검사하여 **합이 0인 줄의 개수**를 센다.

```python
def check_bingo(board):
    bingo_count = 0
    
    # 1. 가로 확인 (Row check)
    for r in range(5):
        row_sum = 0
        for c in range(5):
            row_sum += board[r][c]
        if row_sum == 0:
            bingo_count += 1
            
    # 2. 세로 확인 (Col check)
    for c in range(5):
        col_sum = 0
        for r in range(5):
            col_sum += board[r][c]
        if col_sum == 0:
            bingo_count += 1
            
    # 3. 우하향 대각선 (Left-Top to Right-Bottom)
    diag1_sum = 0
    for i in range(5):
        diag1_sum += board[i][i] # (0,0), (1,1)...
    if diag1_sum == 0:
        bingo_count += 1
        
    # 4. 좌하향 대각선 (Right-Top to Left-Bottom)
    diag2_sum = 0
    for i in range(5):
        diag2_sum += board[i][4 - i] # (0,4), (1,3)...
    if diag2_sum == 0:
        bingo_count += 1
        
    return bingo_count

# 사용법: 사회자가 숫자 부를 때마다 해당 숫자 0으로 만들고 check_bingo() 호출

```