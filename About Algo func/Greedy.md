
# [Algorithm] 그리디 알고리즘 (Greedy Algorithm)

## 1. 개념 (Definition)

그리디 알고리즘(탐욕법)은 이름 그대로 **"현재 상황에서 지금 당장 좋은 것만 고르는 방법"**을 의미한다.
미래에 미칠 영향이나 최종 결과를 고려하지 않고, **매 순간 가장 최적이라고 생각되는 선택**을 진행하여 최종 해답에 도달하는 방식이다.

* **핵심:** 기준에 따라 '가장 큰 순서대로' 혹은 '가장 작은 순서대로'와 같은 정렬(Sorting) 개념과 짝을 이뤄 출제되는 경우가 많다.

## 2. 동작 원리 (Mechanism)

그리디 알고리즘은 보통 다음의 3단계를 반복하며 문제를 해결한다.

1. **해 선택 (Selection Procedure):** 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다.
2. **적절성 검사 (Feasibility Check):** 선택한 해가 문제의 조건(제약 조건)을 위반하지 않는지 검사한다.
3. **해 검사 (Solution Check):** 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 1번으로 돌아간다.

## 3. 정당성 조건 (Conditions)

그리디 알고리즘은 모든 문제에 적용할 수 없다. 다음 두 가지 조건이 성립해야만 **최적의 해(Global Optimum)**를 보장할 수 있다.

1. **탐욕적 선택 속성 (Greedy Choice Property):** 이전의 선택이 이후의 선택에 영향을 주지 않아야 한다. 즉, 앞의 선택이 항상 최적이어야 한다.
2. **최적 부분 구조 (Optimal Substructure):** 문제의 전체 최적해(Global Optimum)가 부분 문제의 최적해(Local Optimum)들로 구성되어야 한다.

> **💡 주의할 점:**
> 그리디 알고리즘은 "최적의 해"를 항상 보장하지 않는다. 하지만 속도가 매우 빠르기 때문에, 최적해에 근사한 값을 빠르게 찾아야 하거나, 문제 특성상 탐욕적 선택이 정당한 경우(예: 거스름돈 문제)에 주로 사용된다.

## 4. 예시 문제: 거스름돈 (Coin Change)

가장 대표적인 그리디 알고리즘 예시다.

* **문제:** 1,260원을 거슬러 줘야 할 때, 500원, 100원, 50원, 10원 동전을 사용하여 동전의 개수를 최소한으로 줄여라.
* **아이디어:** "가장 큰 화폐 단위부터" 돈을 거슬러 주면 된다.

### Python 구현 (`hj0543`님 맞춤 코드)

```python
n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인
coin_types = [500, 100, 50, 10]

for coin in coin_types:
    # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
    count += n // coin
    # 남은 돈 갱신
    n %= coin

print(f"필요한 동전의 최소 개수: {count}")

```

### 이 문제가 그리디로 풀리는 이유

가지고 있는 동전 중에서 **큰 단위가 항상 작은 단위의 배수**이기 때문이다. (500원은 100원의 배수, 100원은 50원의 배수...)
만약 화폐 단위가 `[500, 400, 100]`이었다면, 800원을 거슬러 줄 때 그리디는 `500+100+100+100` (4개)를 내놓겠지만, 실제 최적해는 `400+400` (2개)이므로 그리디를 사용할 수 없다. (이때는 다이나믹 프로그래밍을 써야 한다.)

## 5. 그리디 알고리즘의 활용 (Applications)

* **거스름돈 문제:** 화폐 단위가 배수 관계일 때.
* **활동 선택 문제 (Activity Selection Problem):** 한 강의실에서 최대한 많은 수업을 배정하는 문제.
* **최소 신장 트리 (MST):** 크루스칼(Kruskal), 프림(Prim) 알고리즘.
* **다익스트라 (Dijkstra):** 최단 경로 찾기 (특정 노드까지의 최단 거리를 확정하며 진행하므로 그리디의 일종으로 봄).

## 6. 요약 (Summary)

* **What:** 매 순간 최선의 선택을 하는 방식.
* **When:** 탐욕적 선택이 전체 문제의 최적해를 보장한다는 증명이 가능할 때. (주로 정렬 후 선택하는 로직)
* **Why:** 다이나믹 프로그래밍(DP)보다 수행 시간이 빠르다.

---

이 개념을 바로 적용해볼 수 있는 **백준 11047번 (동전 0)** 또는 **백준 1931번 (회의실 배정)** 문제를 풀어볼 예정
