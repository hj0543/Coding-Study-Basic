
# 📝 파이썬 메서드 완벽 정리 (Instance vs Class vs Static)

클래스 내부에 정의된 함수로, 객체가 **어떻게 동작할지**를 정의한다.

## 1. 인스턴스 메서드 (Instance Method)

가장 기본이 되는 메서드로, **개별 인스턴스의 상태(값)를 조작**할 때 사용한다.

### 특징 및 구조

* **`self` 필수**: 첫 번째 인자로 반드시 인스턴스 자신(`self`)을 받는다.
* **호출**: 인스턴스를 통해 호출한다. (`instance.method()`)

```python
class MyClass:
    def instance_method(self, arg1):
        pass

```

### `self`의 동작 원리 (숨겨진 진실)

`'hello'.upper()`를 호출하면 파이썬 내부는 사실 이렇게 동작한다.

> **`str.upper('hello')`**
> 1. `str` 클래스의 `upper` 함수를 찾는다.
> 2. 첫 번째 인자로 `'hello'` 객체(인스턴스)를 자동으로 넘긴다.
> 3. 그래서 정의할 때 첫 번째 인자(`self`)를 받아야 하는 것이다.
> 
> 

### 활용 예시 (카운터)

각 인스턴스마다 `count` 값이 따로 관리된다.

```python
class Counter:
    def __init__(self):
        self.count = 0 
        
    def increment(self):
        self.count += 1  # 나(self)의 count만 1 증가

c1 = Counter()
c2 = Counter()

c1.increment() 
print(c1.count) # 1
print(c2.count) # 0 (c1과 독립적임)

```

---

## 2. 생성자 메서드 (`__init__`)

인스턴스가 **생성될 때 자동으로 호출**되는 특별한 인스턴스 메서드이다.
주로 인스턴스 변수의 **초기값 설정**을 담당한다.

```python
class Person:
    def __init__(self, name):
        self.name = name # 인스턴스 변수 초기화
        print("생성됨!")

p1 = Person('지민') # __init__ 자동 호출

```

---

## 3. 클래스 메서드 (Class Method)

인스턴스가 아닌 **클래스 자체의 상태(클래스 변수)**를 조작할 때 사용한다.

### 특징 및 구조

* **`@classmethod`**: 데코레이터를 반드시 붙여야 한다.
* **`cls` 필수**: 첫 번째 인자로 클래스 자신(`cls`)을 받는다.
* **호출**: 클래스 이름으로 호출하는 것이 정석이다. (`Class.method()`)

```python
class MyClass:
    @classmethod
    def class_method(cls, arg1):
        pass

```

### 활용 예시 (인구 수 조사)

모든 인스턴스가 공유하는 값을 다룰 때 유용하다.

```python
class Person:
    population = 0 # 클래스 변수 (공유)

    def __init__(self, name):
        self.name = name
        Person.increase_population() # 생성될 때마다 클래스 메서드 호출

    @classmethod
    def increase_population(cls):
        cls.population += 1 # 클래스 변수 수정

p1 = Person('Alice')
p2 = Person('Bob')
print(Person.population) # 2

```

---

## 4. 스태틱 메서드 (Static Method)

클래스 안에 들어있긴 하지만, **인스턴스나 클래스의 상태와는 전혀 상관없는** 독립적인 함수다.

### 특징 및 구조

* **`@staticmethod`**: 데코레이터를 붙인다.
* **인자 없음**: `self`나 `cls`를 받지 않는다. (일반 함수와 똑같음)
* **용도**: 클래스와 논리적으로 연관은 있지만, 데이터를 직접 건드리지 않는 **단순 유틸리티(도우미) 기능**을 할 때 사용한다.

```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b # self나 cls 없이 그냥 계산만 함

print(MathUtils.add(3, 5)) # 8

```

---

## 5. 핵심 요약 및 선택 기준

### 한눈에 비교하기

| 종류 | 데코레이터 | 첫 번째 인자 | 주 사용 목적 |
| --- | --- | --- | --- |
| **인스턴스 메서드** | 없음 | `self` (인스턴스) | 개별 객체의 속성(`self.name`) 조작 |
| **클래스 메서드** | `@classmethod` | `cls` (클래스) | 클래스 속성(`cls.population`) 조작 |
| **스태틱 메서드** | `@staticmethod` | 없음 | 클래스/인스턴스 정보가 필요 없는 단순 기능 |

### 💡 메서드 선택 가이드 (Tip)

코드를 짤 때 "어떤 메서드를 써야 하지?" 고민된다면 아래 질문을 던져보자.

1. **"개별 데이터(이름, 나이 등)를 써야 하는가?"**
* Yes → **인스턴스 메서드** (90% 이상이 여기 해당됨)


2. **"모든 객체가 공유하는 값(총 인원 수 등)을 바꿔야 하는가?"**
* Yes → **클래스 메서드**


3. **"그냥 기능만 수행하면 되고, 내 정보나 클래스 정보는 필요 없는가?"**
* Yes → **스태틱 메서드**



---

✅ **다음 단계**
클래스의 기능을 확장하고 재사용하는 **상속(Inheritance)**의 개념과, 부모 클래스의 기능을 덮어쓰는 **메서드 오버라이딩(Overriding)**에 대해 정리해보자