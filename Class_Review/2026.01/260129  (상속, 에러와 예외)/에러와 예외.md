
# 📝 에러와 예외 처리 (Error & Exception)

프로그램이 실행되는 동안 발생할 수 있는 오류를 사전에 예측하고 처리하여, **프로그램이 비정상적으로 종료되는 것을 막는 기술**이다.

## 1. 디버깅 (Debugging)

소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정이다.

* **버그(Bug)**: 소프트웨어 오작동의 원인이 되는 오류
* **디버깅**: 잘못된 프로그램을 수정하는 모든 활동

---

## 2. 에러와 예외의 차이

프로그램의 오류는 크게 두 가지 시점에서 발생한다.

### ① 문법 에러 (Syntax Error)

프로그램이 **실행되기 전(Parsing 단계)**에 발생하는 오류이다. 문법이 틀렸기 때문에 프로그램 자체가 실행되지 않는다.

* `SyntaxError`: 문법 오류 (괄호 누락, 콜론 누락 등)
* `IndentationError`: 들여쓰기 오류

```python
# SyntaxError 예시
if True
    print("콜론이 빠졌습니다.") 
# SyntaxError: expected ':'

```

### ② 예외 (Exception)

문법은 맞지만, **프로그램 실행 도중(Runtime)**에 발생하는 오류이다. 처리하지 않으면 프로그램이 멈춘다.

* `NameError`: 정의되지 않은 변수 사용
* `TypeError`: 자료형 불일치 (예: `1 + '1'`)
* `ValueError`: 타입은 맞으나 값이 적절하지 않음 (예: `int('hello')`)
* `ZeroDivisionError`: 0으로 나누기
* `IndexError`: 리스트 범위를 벗어난 인덱스 접근

---

## 3. 예외 처리 (Exception Handling)

예외가 발생했을 때 프로그램이 죽지 않고, **적절한 조치를 취한 뒤 계속 실행**되도록 하는 구문이다.

### 기본 구조 (`try-except`)

* **`try`**: 예외가 발생할 가능성이 있는 코드를 작성한다.
* **`except`**: 예외가 발생했을 때 실행할 코드를 작성한다.

```python
try:
    num = int(input("숫자를 입력하세요: "))
    result = 10 / num
    print(f"결과: {result}")

except ZeroDivisionError:
    print("0으로 나눌 수 없습니다.")

except ValueError:
    print("숫자만 입력해야 합니다.")

```

### 복수 예외 처리와 주의사항

* **상위 클래스 주의**: `Exception` 같은 상위 예외 클래스를 먼저 적으면, 하위 예외들이 모두 그곳에 걸리게 된다. **구체적인 예외(하위)를 먼저 적고, 포괄적인 예외(상위)를 나중에 적어야 한다.**

```python
try:
    # 코드
    pass
except Exception: # 모든 에러를 다 잡음 (디버깅 어려움)
    print("에러 발생")
except ZeroDivisionError: # 위에서 잡혀서 여기까지 오지도 않음 (Unreachable code)
    print("0으로 나눔") 

```

---

## 4. `else`와 `finally`

예외 발생 여부와 상관없이 처리해야 할 로직을 위해 사용한다.

* **`else`**: 예외가 **발생하지 않았을 때만** 실행된다.
* **`finally`**: 예외 발생 여부와 상관없이 **무조건 실행**된다. (주로 파일 닫기, DB 연결 끊기 등 리소스 해제에 사용)

```python
try:
    f = open('data.txt', 'r')
    data = f.read()
except FileNotFoundError:
    print("파일이 없습니다.")
else:
    print("파일 읽기 성공!") # 에러 없을 때만 실행
finally:
    print("작업을 종료합니다.") # 무조건 실행

```

---

## 5. 예외 발생시키기 (`raise`)

개발자가 의도적으로 에러를 발생시켜야 할 때 사용한다. (예: 억지로 규칙을 어긴 값을 입력했을 때)

```python
def check_age(age):
    if age < 0:
        raise ValueError("나이는 음수일 수 없습니다.")
    print(f"나이: {age}")

try:
    check_age(-5)
except ValueError as e:
    print(e) # 나이는 음수일 수 없습니다.

```

---

## 6. EAFP vs LBYL

파이썬이 권장하는 코딩 스타일(철학)의 차이이다.

### ① EAFP (It's Easier to Ask Forgiveness than Permission)

**"허락보다 용서가 쉽다."**

* 일단 실행하고(`try`), 에러가 나면 처리(`except`)하는 방식.
* **파이썬스러운(Pythonic)** 방식이다.

```python
# EAFP (Pythonic)
try:
    print(my_dict['key'])
except KeyError:
    print("키가 없습니다.")

```

### ② LBYL (Look Before You Leap)

**"돌다리도 두들겨 보고 건너라."**

* 실행하기 전에 조건문(`if`)으로 검사하는 방식.

```python
# LBYL
if 'key' in my_dict:
    print(my_dict['key'])
else:
    print("키가 없습니다.")

```

---

✅ **다음 단계**
이제 객체 지향과 예외 처리까지 정리했다. 다음으로는 객체 지향의 심화 개념인 **다형성(Polymorphism)**이나, 파이썬의 꽃이라 불리는 **장식자(Decorator)**에 대해 정리해 보자.