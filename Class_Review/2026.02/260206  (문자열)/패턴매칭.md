
# 📝 [TIL] 02.06 - 문자열 패턴 매칭 (Pattern Matching)

> **"긴 글(Text) 속에서 특정 단어(Pattern)를 어떻게 빨리 찾을까?"**

## 1. 고지식한 알고리즘 (Brute Force)

가장 직관적이고 구현하기 쉬운 방법. **IM 등급**에서는 이 방법만 완벽하게 구현해도 충분하다.

* **원리**: 본문(`T`)의 첫 글자부터 패턴(`P`)을 대보며, 안 맞으면 **한 칸 옆으로 이동**해서 처음부터 다시 비교한다.
* **시간 복잡도**:  (최악의 경우).
* 예: `TTTTTTTTTA` 에서 `TA` 찾기.


* **구현 포인트**:
* `i`: 본문의 인덱스, `j`: 패턴의 인덱스.
* 비교 중 틀리면?  `i`는 `i - j + 1` (시작점 다음 칸)로, `j`는 `0`으로 초기화.



```python
def brute_force(p, t):
    i = 0 # 본문(t) 인덱스
    j = 0 # 패턴(p) 인덱스
    M = len(p)
    N = len(t)

    while j < M and i < N:
        if t[i] != p[j]:
            # 틀렸을 때: i를 되돌리고 j는 0으로
            i = i - j
            j = -1 
        i = i + 1
        j = j + 1

    if j == M: return i - M # 찾은 시작 위치 반환
    else: return -1 # 실패

```
사실 IM 시험이나 코딩테스트 현장에서는 인덱스 관리가 까다로운 `while`문보다, **`range()`를 이용한 2중 for문**이 훨씬 직관적이고 실수할 확률이 적다.

---

### 💻 [Code] 고지식한 패턴 검색 (Brute Force) - 2중 for문 버전

가장 추천하는 방식입니다. 슬라이딩 윈도우처럼 패턴을 한 칸씩 밀면서 비교합니다.

```python
def brute_force_for(text, pattern):
    N = len(text)    # 전체 텍스트 길이
    M = len(pattern) # 찾을 패턴 길이
    
    # 1. 시작점(i) 순회
    # 인덱스 에러 방지를 위해 (N - M + 1)까지만 돈다.
    # 예: 길이가 10인 글에서 길이 3인 패턴을 찾으려면, 인덱스 7까지만 시작 가능
    for i in range(N - M + 1):
        
        is_match = True # 일단 맞다고 가정
        
        # 2. 패턴 내 문자(j) 비교
        for j in range(M):
            # 하나라도 다르면 실패 -> 즉시 break
            if text[i + j] != pattern[j]:
                is_match = False
                break
        
        # 3. 안쪽 for문이 break 없이 끝났다면 성공
        if is_match:
            return i # 찾은 시작 위치 반환
            
    return -1 # 끝까지 못 찾음

# 사용 예시
t = "A pattern matching algorithm"
p = "match"
print(brute_force_for(t, p)) # 10 출력

```

### 💡 코드 핵심 포인트

1. **바깥쪽 `for i**`: `range(N - M + 1)`
* 패턴이 텍스트 밖으로 삐져나가지 않도록 범위를 제한하는 것이 핵심입니다.


2. **안쪽 `for j**`: `text[i + j]` vs `pattern[j]`
* `i`는 고정해두고 `j`를 늘려가며 비교합니다.


3. **`break` 활용**: 틀린 글자가 나오자마자 안쪽 루프를 멈춰 불필요한 비교를 줄입니다.
---

## 2. KMP 알고리즘 (Knuth-Morris-Pratt)

"불일치가 발생했을 때, 우리가 이미 비교했던 정보를 버리지 말자!"

* **원리**: 패턴 내에서 **접두사(Prefix)와 접미사(Suffix)가 일치하는 부분**을 미리 계산해둔다. 틀렸을 때, 맨 처음으로 돌아가는 게 아니라 **"접두사가 일치했던 지점"**으로 점프한다.
* **핵심 개념**: `next` 배열 (또는 `pi` 테이블, 실패 함수).
* 패턴의 각 위치까지의 부분 문자열 중, **접두사이면서 동시에 접미사인 가장 긴 문자열의 길이**를 저장.


* **시간 복잡도**:  (획기적으로 빠름).

> **💡 요약**: "아까 검사한 거랑 앞부분이랑 똑같네? 거긴 건너뛰고 그 뒤부터 비교하자!"

---

## 3. 보이어-무어 알고리즘 (Boyer-Moore)

실제 상용 소프트웨어(에디터 등)에서 가장 많이 쓰이는, **평균적으로 가장 빠른** 알고리즘.

* **원리**: 패턴의 **오른쪽 끝**부터 비교한다. (앞부분은 대부분 안 맞을 확률이 높으니까)
* **핵심 규칙 (Bad Character Rule)**:
* 끝에서 비교했는데 틀렸다?
* 본문의 문자가 패턴에 **아예 없는 문자**라면?  패턴 길이만큼 통째로 점프!
* 패턴에 **있는 문자**라면?  그 문자가 맞춰지도록 칸을 이동.


* **시간 복잡도**: 최악은 $O(MN)$이지만, 일반적인 상황에서는 $O(N)$보다 훨씬 빠르다. (약 )

> **💡 요약**: "뒤에서부터 봤는데 틀렸어? 근데 이 문자는 아예 없네? 그럼 패턴 전체를 확 넘겨버려!"

---

## 📊 3가지 알고리즘 비교 (한눈에 보기)

| 알고리즘 | 비교 방향 | 핵심 아이디어 | 시간 복잡도 (최악) | 난이도 | 비고 |
| --- | --- | --- | --- | --- | --- |
| **Brute Force** | 앞  뒤 | 하나씩 다 해본다. |  | 하 | **[IM 필수]** 가장 기본 |
| **KMP** | 앞  뒤 | 접두사/접미사 일치 정보 활용 (점프) |  | 상 | 코테에서 가끔 등장 |
| **Boyer-Moore** | **뒤  앞** | 불일치 문자를 보고 건너뛰기 (Skip) |  | 상 | 실무에서 가장 빠름 |

---

## 🚀 실전 적용 팁 (Python)

알고리즘 대회에서 **"문자열 매칭을 직접 구현하라"**는 제약이 없다면, 파이썬 내장 함수가 KMP나 보이어-무어보다 빠르고 효율적이다. (C로 최적화되어 있음)

1. **존재 여부 확인**: `if pattern in text:`
2. **위치 찾기**: `text.find(pattern)` (인덱스 반환, 없으면 -1)
3. **개수 세기**: `text.count(pattern)`

**하지만!**
A형이나 면접을 대비한다면 **Brute Force(2중 반복문)로 직접 구현하는 능력**은 반드시 갖춰야 한다. 인덱스를 조작하는 가장 기초적인 훈련이기 때문이다.