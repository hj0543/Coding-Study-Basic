
# 📝 정렬 (Sorting)

2개 이상의 자료를 특정 기준(키)에 따라 오름차순(작은 값→큰 값) 또는 내림차순(큰 값→작은 값)으로 재배열하는 것이다.

## 1. 버블 정렬 (Bubble Sort)

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식이다.

### 특징

* **작동 원리**: 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하며 맨 마지막 자리로 이동한다. 한 단계가 끝나면 가장 큰 원소가 마지막 자리에 확정된다.
* **시간 복잡도**:  - 비교적 느리다.
* **장점**: 구현이 매우 간단하다.

### 구현 코드

```python
def bubble_sort(arr):
    N = len(arr)
    # i: 구간의 끝 인덱스 (뒤에서부터 정렬 완료됨)
    for i in range(N-1, 0, -1):
        # j: 비교할 인덱스 (0부터 i-1까지)
        for j in range(0, i):
            if arr[j] > arr[j+1]:
                # 교환 (Swap)
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

```

---

## 2. 카운팅 정렬 (Counting Sort)

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘이다.

### 특징

* **제한 사항**: **정수**나 정수로 표현 가능한 자료형이어야 한다. 집합 내의 가장 큰 정수를 알아야 한다.
* **시간 복잡도**:  (은 리스트 길이, 는 정수의 최댓값)
* **공간 복잡도**: 값(최댓값)이 너무 크면 메모리 낭비가 심하다.

### 구현 프로세스 (1단계 ~ 4단계)

1. **Data counting**: 각 항목의 발생 횟수를 세고, 정수 항목들로 인덱스 되는 카운트 배열(`counts`)에 저장한다.
2. **Cumulative counts**: `counts` 배열의 원소를 누적합으로 갱신한다. (각 값이 들어갈 위치 정보를 계산하기 위함)
3. **Sorting**: 원본 데이터를 뒤에서부터 순회하며 `counts` 배열을 참조해 결과 배열(`TEMP`)의 적절한 위치에 배치한다.
4. **Decrement**: 배치 후 `counts` 값을 1 감소시킨다.

### 구현 코드

```python
def counting_sort(arr, k):
    """
    arr: 입력 배열 (0 ~ k)
    k: 데이터의 최댓값
    """
    N = len(arr)
    counts = [0] * (k + 1)
    temp = [0] * N

    # 1. 개수 세기
    for x in arr:
        counts[x] += 1

    # 2. 누적 합 구하기
    for i in range(1, k + 1):
        counts[i] += counts[i-1]

    # 3. 뒤에서부터 순회하며 배치 (안정 정렬을 위해)
    for i in range(N - 1, -1, -1):
        counts[arr[i]] -= 1     # 개수 감소 (인덱스로 보정)
        temp[counts[arr[i]]] = arr[i]

    return temp

```

---

## 3. 정렬 알고리즘 비교

| 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징 |
| --- | --- | --- | --- |
| **버블 정렬** |  |  | 코딩이 가장 쉽다. 데이터가 많으면 매우 느리다. |
| **카운팅 정렬** |  |  | 이 비교적 작을 때만 가능하다. 빠르지만 메모리를 많이 쓴다. |

---

## 4. 완전 검색 (Exhaustive Search)

문제의 해법으로 생각할 수 있는 **모든 경우의 수**를 나열해보고 확인하는 기법이다. (Brute-force)

* **특징**: 모든 경우를 다 검사하므로 해를 찾을 확률이 100%다.
* **활용**: 문제의 크기(입력값)가 작을 때 유용하다.
* **순열(Permutation)**: 서로 다른 n개 중 r개를 택하여 나열하는 것. () 완전 검색에서 순서를 따지는 경우의 수를 생성할 때 사용한다.

---

## 5. 탐욕 알고리즘 (Greedy)

최적해를 구하는 데 사용되는 근시안적인 방법이다.

* 여러 경우 중 하나를 결정할 때마다 **그 순간에 최적이라고 생각되는 것**을 선택해 나간다.
* **주의**: 각 단계의 최적 선택이 전체의 최적해라는 보장은 없다.

### 예시: Baby-gin Game

6장의 카드가 `run`(연속된 3숫자)과 `triplet`(동일한 3숫자)으로만 구성되어 있는지 확인하는 게임.

* **완전 검색 접근**: 6장의 카드로 만들 수 있는 모든 순열을 생성하여 확인한다.
* **탐욕적 접근 (Counts 배열 활용)**:
1. `counts` 배열에 숫자 빈도수를 기록한다.
2. `triplet` 확인: `counts[i] >= 3`이면 3을 빼고 `triplet` 처리.
3. `run` 확인: `counts[i], counts[i+1], counts[i+2] >= 1`이면 각각 1을 빼고 `run` 처리.
4. 최종적으로 두 번의 처리가 성공하면 Baby-gin이다.



---

✅ **다음 단계**
정렬과 배열 활용의 기초를 다졌으니, 2차원 배열에서 **이진 검색(Binary Search)**을 통해 원하는 값을 빠르게 찾는 방법과, 배열의 특정 부분합을 구하는 **슬라이딩 윈도우** 기법에 대해 정리해 보자.